name: Release Workflow

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag name for release (e.g., v1.2.0)'
        required: true
        type: string
      deploy_environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  # Pre-release validation gates
  validation:
    name: Release Validation Gates
    runs-on: ubuntu-latest
    timeout-minutes: 15

    outputs:
      version: ${{ steps.version.outputs.version }}
      should_deploy: ${{ steps.gates.outputs.should_deploy }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for version detection

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-xdist

      - name: Extract version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.tag_name }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version: ${VERSION}"

      # Gate 1: Accuracy validation
      - name: Gate 1 - Accuracy Validation
        run: |
          echo "üéØ Running accuracy validation..."

          # Test against known golden values
          python -m pytest tests/ -v \
            -k "accuracy or golden" \
            --tb=short \
            -x

          echo "‚úÖ Accuracy validation passed"

      # Gate 2: Performance benchmarks
      - name: Gate 2 - Performance Validation
        run: |
          echo "‚ö° Running performance benchmarks..."

          # Start engine in background
          export DISABLE_RATE_LIMIT=1
          python -m uvicorn main:app --host 0.0.0.0 --port 8080 &
          ENGINE_PID=$!

          # Wait for startup
          sleep 5

          # Performance test - should respond in <100ms avg
          echo "Testing response times..."
          for i in {1..10}; do
            start_time=$(date +%s%3N)
            curl -s -X POST http://localhost:8080/v1/positions \
              -H "Content-Type: application/json" \
              -d '{
                "when": {"utc": "2023-12-25T12:00:00Z"},
                "system": "tropical",
                "bodies": ["Sun", "Moon", "Mercury", "Venus", "Mars"]
              }' > /dev/null
            end_time=$(date +%s%3N)
            response_time=$((end_time - start_time))
            echo "Request $i: ${response_time}ms"

            if [ $response_time -gt 100 ]; then
              echo "‚ùå Performance gate failed: ${response_time}ms > 100ms threshold"
              kill $ENGINE_PID
              exit 1
            fi
          done

          kill $ENGINE_PID
          echo "‚úÖ Performance validation passed"

      # Gate 3: API contract validation
      - name: Gate 3 - API Contract Validation
        run: |
          echo "üìã Validating API contracts..."

          # Start engine
          export DISABLE_RATE_LIMIT=1
          python -m uvicorn main:app --host 0.0.0.0 --port 8080 &
          ENGINE_PID=$!
          sleep 5

          # Test required endpoints
          endpoints=(
            "/healthz"
            "/v1/positions"
          )

          for endpoint in "${endpoints[@]}"; do
            echo "Testing ${endpoint}..."
            if [[ "$endpoint" == "/v1/positions" ]]; then
              # POST request for positions
              response=$(curl -s -w "%{http_code}" -X POST \
                http://localhost:8080${endpoint} \
                -H "Content-Type: application/json" \
                -d '{
                  "when": {"utc": "2023-12-25T12:00:00Z"},
                  "system": "tropical",
                  "bodies": ["Sun"]
                }')
            else
              # GET request for health
              response=$(curl -s -w "%{http_code}" \
                http://localhost:8080${endpoint})
            fi

            http_code="${response: -3}"
            if [[ "$http_code" != "200" ]]; then
              echo "‚ùå API contract failed: ${endpoint} returned ${http_code}"
              kill $ENGINE_PID
              exit 1
            fi
            echo "‚úÖ ${endpoint} responded with 200"
          done

          kill $ENGINE_PID
          echo "‚úÖ API contract validation passed"

      # Gate 4: Security scan
      - name: Gate 4 - Security Validation
        run: |
          echo "üîí Running security validation..."

          # Check for secrets in code
          if grep -r -i "password\|secret\|key" --include="*.py" . | grep -v "test" | grep -v "example"; then
            echo "‚ùå Security gate failed: Potential secrets found"
            exit 1
          fi

          # Check dependencies for known vulnerabilities
          pip install safety
          safety check --json || {
            echo "‚ùå Security gate failed: Vulnerable dependencies found"
            exit 1
          }

          echo "‚úÖ Security validation passed"

      # Final gate decision
      - name: Final Gate Decision
        id: gates
        run: |
          echo "üéâ All release gates passed!"
          echo "should_deploy=true" >> $GITHUB_OUTPUT

  # Build release artifacts
  build:
    name: Build Release Artifacts
    runs-on: ubuntu-latest
    needs: validation
    if: needs.validation.outputs.should_deploy == 'true'
    timeout-minutes: 10

    outputs:
      image_tag: ${{ steps.image.outputs.tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        id: image
        run: |
          IMAGE_TAG="involution-engine:${{ needs.validation.outputs.version }}"
          echo "Building ${IMAGE_TAG}..."

          docker build -t "${IMAGE_TAG}" \
            --build-arg VERSION="${{ needs.validation.outputs.version }}" \
            -f docker/Dockerfile .

          # Save image for potential deployment
          docker save "${IMAGE_TAG}" > engine-image.tar

          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v3
        with:
          name: engine-image
          path: engine-image.tar
          retention-days: 7

  # Deploy to staging first
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [validation, build]
    if: needs.validation.outputs.should_deploy == 'true'
    timeout-minutes: 10
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v3
        with:
          name: engine-image

      - name: Load and deploy to staging
        run: |
          docker load < engine-image.tar

          echo "üöÄ Deploying ${{ needs.build.outputs.image_tag }} to staging..."

          # Simulate staging deployment
          # In real deployment, this would push to staging registry
          # and trigger staging environment update

          echo "‚úÖ Staging deployment simulated successfully"
          echo "Staging URL: https://staging.involution-engine.com"

  # Staging validation
  staging-validation:
    name: Staging Validation
    runs-on: ubuntu-latest
    needs: [deploy-staging, validation]
    timeout-minutes: 10

    steps:
      - name: Validate staging deployment
        run: |
          echo "üß™ Validating staging deployment..."

          # In real implementation, these would test actual staging URL
          STAGING_URL="https://staging.involution-engine.com"

          echo "Testing health endpoint..."
          # curl -f "${STAGING_URL}/healthz" || exit 1

          echo "Testing positions endpoint..."
          # curl -f -X POST "${STAGING_URL}/v1/positions" \
          #   -H "Content-Type: application/json" \
          #   -d '{"when": {"utc": "2023-12-25T12:00:00Z"}, "system": "tropical", "bodies": ["Sun"]}' \
          #   || exit 1

          echo "‚úÖ Staging validation passed"

  # Production deployment (manual approval required)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [staging-validation, validation, build]
    if: |
      needs.validation.outputs.should_deploy == 'true' &&
      (github.event.inputs.deploy_environment == 'production' ||
       github.event_name == 'push')
    timeout-minutes: 15
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image
        uses: actions/download-artifact@v3
        with:
          name: engine-image

      - name: Deploy to production
        run: |
          docker load < engine-image.tar

          echo "üöÄ Deploying ${{ needs.build.outputs.image_tag }} to production..."

          # Simulate production deployment
          # In real deployment:
          # 1. Push image to production registry
          # 2. Update Kubernetes/Docker Swarm deployment
          # 3. Perform canary deployment if configured
          # 4. Run post-deployment validation

          echo "‚úÖ Production deployment simulated successfully"
          echo "Production URL: https://api.involution-engine.com"

  # Post-deployment validation
  production-validation:
    name: Production Validation
    runs-on: ubuntu-latest
    needs: [deploy-production]
    timeout-minutes: 10

    steps:
      - name: Validate production deployment
        run: |
          echo "üîç Validating production deployment..."

          # In real implementation, these would test actual production URL
          PROD_URL="https://api.involution-engine.com"

          echo "Testing health endpoint..."
          # curl -f "${PROD_URL}/healthz" || exit 1

          echo "Testing positions endpoint..."
          # curl -f -X POST "${PROD_URL}/v1/positions" \
          #   -H "Content-Type: application/json" \
          #   -d '{"when": {"utc": "2023-12-25T12:00:00Z"}, "system": "tropical", "bodies": ["Sun"]}' \
          #   || exit 1

          echo "Testing response time..."
          # Ensure production response time is acceptable

          echo "‚úÖ Production validation passed"

  # Create GitHub release
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [production-validation, validation]
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        id: notes
        run: |
          VERSION="${{ needs.validation.outputs.version }}"

          # Generate release notes from commits since last tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -n "$PREV_TAG" ]; then
            echo "Changes since ${PREV_TAG}:" > release_notes.md
            git log --pretty=format:"- %s" ${PREV_TAG}..HEAD >> release_notes.md
          else
            echo "Initial release" > release_notes.md
          fi

          echo "Release notes generated for ${VERSION}"
          cat release_notes.md

      - name: Create release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.validation.outputs.version }}
          release_name: Release ${{ needs.validation.outputs.version }}
          body_path: release_notes.md
          draft: false
          prerelease: ${{ contains(needs.validation.outputs.version, '-') }}

  # Notification
  notify:
    name: Release Notification
    runs-on: ubuntu-latest
    needs: [create-release, validation]
    if: always()

    steps:
      - name: Notify release status
        run: |
          VERSION="${{ needs.validation.outputs.version }}"

          if [[ "${{ needs.create-release.result }}" == "success" ]]; then
            echo "üéâ Release ${VERSION} completed successfully!"
            echo "Production: https://api.involution-engine.com"
            echo "Documentation: https://docs.involution-engine.com"
          else
            echo "‚ùå Release ${VERSION} failed"
            echo "Check workflow logs for details"
          fi